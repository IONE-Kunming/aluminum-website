rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check user role
    function hasRole(role) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return hasRole('admin');
    }
    
    // Users collection
    match /users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      // Users can create their own document
      allow create: if isAuthenticated() && request.auth.uid == userId;
      // Users can update their own document
      allow update: if isAuthenticated() && request.auth.uid == userId;
      // Admins can read all users
      allow read: if isAdmin();
      // Allow anyone to query users for seller directory (limited fields returned by application)
      // Note: Application should only return public fields (companyName, email, role)
      allow list: if isAuthenticated();
    }
    
    // Products collection
    match /products/{productId} {
      // Anyone can read products
      allow read: if true;
      // Sellers can create products
      allow create: if hasRole('seller') && request.resource.data.sellerId == request.auth.uid;
      // Sellers can update/delete their own products
      allow update, delete: if hasRole('seller') && 
                               resource.data.sellerId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Orders collection
    match /orders/{orderId} {
      // Buyers can read their own orders
      allow read: if isAuthenticated() && 
                     resource.data.buyerId == request.auth.uid;
      // Buyers can create orders
      allow create: if hasRole('buyer') && request.resource.data.buyerId == request.auth.uid;
      // Sellers can read orders for their products
      allow read: if isAuthenticated() && 
                     hasRole('seller') && 
                     resource.data.sellerId == request.auth.uid;
      // Sellers can update order status
      allow update: if hasRole('seller') && resource.data.sellerId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Carts collection
    match /carts/{userId} {
      // Users can read and write their own cart
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Invoices collection
    match /invoices/{invoiceId} {
      // Buyers can read their own invoices
      allow read: if isAuthenticated() && 
                     resource.data.buyerId == request.auth.uid;
      // Sellers can read their own invoices
      allow read: if isAuthenticated() && 
                     resource.data.sellerId == request.auth.uid;
      // Buyers can create invoices for their orders
      allow create: if hasRole('buyer') && 
                       request.resource.data.buyerId == request.auth.uid;
      // Sellers can create and update invoices
      allow create, update: if hasRole('seller') && 
                               request.resource.data.sellerId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Branches collection
    match /branches/{branchId} {
      // Anyone can read branches
      allow read: if true;
      // Sellers can create their own branches
      allow create: if hasRole('seller') && 
                       request.resource.data.sellerId == request.auth.uid;
      // Sellers can manage their own branches
      allow update, delete: if hasRole('seller') && 
                               resource.data.sellerId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      // Helper to verify chat exists between sender and receiver
      function chatExists(senderId, receiverId) {
        let chatId = senderId < receiverId ? senderId + '_' + receiverId : receiverId + '_' + senderId;
        return exists(/databases/$(database)/documents/chats/$(chatId));
      }
      
      // Users can read their own notifications
      allow read: if isAuthenticated() && 
                     resource.data.userId == request.auth.uid;
      // Users can only create notifications for themselves
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      // Chat participants can create notifications (sender creates notification for receiver)
      // Must verify that a chat exists between them to prevent spam
      allow create: if isAuthenticated() && 
                       request.resource.data.type == 'chat' &&
                       request.resource.data.senderId == request.auth.uid &&
                       chatExists(request.auth.uid, request.resource.data.userId);
      // Users can update their own notifications (mark as read)
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid;
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Chat conversations collection
    match /chats/{chatId} {
      // Participants can read their own chats
      allow read: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
      // Users can create chats
      allow create: if isAuthenticated() && 
                       request.auth.uid in request.resource.data.participants;
      // Participants can update chat (last message, etc.)
      allow update: if isAuthenticated() && 
                       request.auth.uid in resource.data.participants;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Chat messages collection
    match /messages/{messageId} {
      // Participants can read messages in their chats
      allow read: if isAuthenticated() && 
                     (request.auth.uid == resource.data.senderId || 
                      request.auth.uid == resource.data.receiverId);
      // Users can send messages
      allow create: if isAuthenticated() && 
                       request.resource.data.senderId == request.auth.uid;
      // Users can update their own messages (mark as read)
      allow update: if isAuthenticated() && 
                       (request.auth.uid == resource.data.senderId || 
                        request.auth.uid == resource.data.receiverId);
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Support tickets collection
    match /support/{ticketId} {
      // Users can read their own tickets
      allow read: if isAuthenticated() && 
                     resource.data.userId == request.auth.uid;
      // Users can create tickets
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      // Users can update their own tickets
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid;
      // Admins can do anything
      allow read, write: if isAdmin();
    }
    
    // Counters collection (for generating invoice numbers, etc.)
    match /_counters/{counterId} {
      // Only allow invoice counter access during invoice creation
      // Restrict to specific counter documents
      allow read, write: if isAuthenticated() && counterId == 'invoices';
      // Admins can access all counters
      allow read, write: if isAdmin();
    }
  }
}
